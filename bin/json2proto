var ProtoBuf = require(__dirname+"/../index.js"),
    Builder = ProtoBuf.Builder,
    Lang = ProtoBuf.Lang,
    fs = require("fs"),
    path = require("path"),
    pkg = require(__dirname+"/../package.json"),
    ascli = require("ascli");

if (!fs.existsSync) fs.existsSync = path.existsSync; // node 0.6

var options = {};
for (var i=3; i<process.argv.length; i++) {
    var option = process.argv[i];
    if (option.substring(0,1) == "-") {
        var opt = option.split("=", 2), key = opt[0].substring(1);
        if (typeof options[key] === 'string' && typeof opt[1] === 'string') {
            options[key] = [options[key], opt[1]]; // Make it an array
        } else if (Array.isArray(options[key]) && typeof opt[1] === 'string') {
            options[key].push(opt[1]); // Add it
        } else {
            options[key] = opt.length == 2 ? opt[1] : true; // Create or overwrite
        }
    }
}

function makeVal(v) {
    switch (typeof v) {
        case 'boolean':
            return v ? 'true' : 'false';
        case 'number':
            return v.toString();
        case 'string':
            return '"'+v.replace(/"/g, '\\"')+'"';
        default:
            throw new Error("Illegal output value: "+typeof(v));
    }
}

function makeIndent(n) {
    var indent = "";
    while (n--) indent += "    ";
    return indent;
}

var sourceFile = process.argv[2],
    source = fs.readFileSync(sourceFile)+"",
    json = JSON.parse(source),
    out = [];

function makeEnum(enm, indent) {
    if (!Builder.isValidEnum(enm))
        throw Error("Invalid enum definition");
    var out = [];
    out.push(makeIndent(indent)+'enum '+enm.name+' {\n');
    // TODO: Options
    enm.values.forEach(function(value) {
        out.push(makeIndent(indent+1)+value.name+" = "+value.id+";\n");
    });
    out.push(makeIndent(indent)+"}\n");
    return out.join('');
}

function makeMessage(msg, indent) {
    if (!Builder.isValidMessage(msg))
        throw Error("Invalid message definition");
    var out = [];
    out.push(makeIndent(indent)+(msg.isGroup ? "group" : "message")+" "+msg.name+" {\n");
    // TODO: Options
    msg.enums.forEach(function(enm) {
        out.push(makeEnum(enm, indent+1));
    });
    msg.messages.forEach(function(msg) {
        out.push(makeMessage(msg, indent+1));
    });
    msg.fields.forEach(function(fld) {
        out.push(makeIndent(indent+1)+fld.rule+" "+fld.type+" "+fld.name+" = "+fld.id);
        var opt;
        if (fld.options && (opt = Object.keys(fld.options)).length > 0) {
            out.push(" [");
            var n = 0;
            opt.forEach(function(key) {
                var val = fld.options[key];
                if (n > 0) out.push(", ");
                if (key === 'default' && !Lang.TYPE.test(fld.type)) { // Enum value without quotes
                    out.push(key+"="+val);
                } else if (key === 'packed' && typeof val === 'string' && Lang.BOOL.test(val)) {
                    out.push(key+"="+makeVal(val === 'true'));
                } else {
                    out.push(key+"="+makeVal(val));
                }
                n++;
            });
            out.push("]");
        }
        out.push(";\n");
    });
    out.push(makeIndent(indent)+"}\n");
    return out.join('');
}

function makeService(svc, indent) {
    if (!Builder.isValidService(svc))
        throw Error("Invalid service definition");
    var out = [];
    // TODO
    return out.join('');
}

out.push('// '+sourceFile+'\n');
out.push('// generated by ProtoBuf.js json2proto v'+pkg.version+'\n\n');

// package declaration
if (typeof json.package === 'string') {
    out.push('package '+makeVal(json.package)+';\n\n');
}

// global options
if (json.options && typeof json.options === 'object') {
    var n = 0;
    Object.keys(json.options).forEach(function(key) {
        var val = json.options[key];
        out.push('option '+key+' = '+makeVal(val)+';\n');
        n++;
    });
    if (n > 0) out.push("\n");
}

// imports
if (Array.isArray(json.imports) && json.imports.length > 0) {
    json.imports.forEach(function(file) {
        if (typeof file !== 'string') return;
        out.push('import '+makeVal(file)+';\n');
    });
    out.push("\n");
}

// enums
if (Array.isArray(json.enums) && json.enums.length > 0) {
    json.enums.forEach(function(enm) {
        out.push(makeEnum(enm, 0));
    });
}

// messages
if (Array.isArray(json.messages) && json.messages.length > 0) {
    json.messages.forEach(function(msg) {
        out.push(makeMessage(msg, 0));
    });
}

// services
if (Array.isArray(json.services) && json.services.length > 0) {
    json.services.forEach(function(svc) {
        out.push(makeService(svc, 0));
    });
}

process.stdout.write(out.join('').trim()+"\n");
